<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.13" name="generator"/>
<title>OpenCV: Data Structures</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script src="../../jquery.js" type="text/javascript"></script>
<script src="../../dynsections.js" type="text/javascript"></script>
<script src="../../tutorial-utils.js" type="text/javascript"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script src="../../search/searchdata.js" type="text/javascript"></script>
<script src="../../search/search.js" type="text/javascript"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          cameramatrix: ["#1 = \\begin{bmatrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{bmatrix}", 1],
          distcoeffs: ["(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]]) \\text{ of 4, 5, 8, 12 or 14 elements}"],
          distcoeffsfisheye: ["(k_1, k_2, k_3, k_4)"],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js" type="text/javascript"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellpadding="0" cellspacing="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
    <span id="projectnumber">4.9.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script src="../../menudata.js" type="text/javascript"></script>
<script src="../../menu.js" type="text/javascript"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> |
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Data Structures<div class="ingroups"><a class="el" href="../../d1/d1e/group__cuda.html">CUDA-accelerated Computer Vision</a> » <a class="el" href="../../d7/d05/group__cudacore.html">Core part</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html">cv::cuda::BufferPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html" title="BufferPool for use with CUDA streams. ">BufferPool</a> for use with CUDA streams.  <a href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d38/classcv_1_1cuda_1_1Event.html">cv::cuda::Event</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d71/structcv_1_1cuda_1_1EventAccessor.html">cv::cuda::EventAccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Class that enables getting cudaEvent_t from <a class="el" href="../../d5/d38/classcv_1_1cuda_1_1Event.html">cuda::Event</a>.  <a href="../../da/d71/structcv_1_1cuda_1_1EventAccessor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dec/structcv_1_1cuda_1_1GpuData.html">cv::cuda::GpuData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html">cv::cuda::GpuMat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Base storage class for GPU memory with reference counting.  <a href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d0f/classcv_1_1cuda_1_1GpuMatND.html">cv::cuda::GpuMatND</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d44/classcv_1_1cuda_1_1HostMem.html">cv::cuda::HostMem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Class with reference counting wrapping special memory type allocation functions from CUDA.  <a href="../../d0/d44/classcv_1_1cuda_1_1HostMem.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html">cv::cuda::Stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">This class encapsulates a queue of asynchronous calls.  <a href="../../d9/df3/classcv_1_1cuda_1_1Stream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/df1/structcv_1_1cuda_1_1StreamAccessor.html">cv::cuda::StreamAccessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Class that enables getting cudaStream_t from <a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html" title="This class encapsulates a queue of asynchronous calls. ">cuda::Stream</a>.  <a href="../../d6/df1/structcv_1_1cuda_1_1StreamAccessor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3a55474eb59c884697edf397fe0f871c"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d41/group__cudacore__struct.html#ga3a55474eb59c884697edf397fe0f871c">cv::cuda::createContinuous</a> (int rows, int cols, int type, <a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> arr)</td></tr>
<tr class="memdesc:ga3a55474eb59c884697edf397fe0f871c"><td class="mdescLeft"> </td><td class="mdescRight">Creates a continuous matrix.  <a href="../../d9/d41/group__cudacore__struct.html#ga3a55474eb59c884697edf397fe0f871c">More...</a><br/></td></tr>
<tr class="separator:ga3a55474eb59c884697edf397fe0f871c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gac3ca8e6e41d70a228d72422c844dc99c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html">GpuMat</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d41/group__cudacore__struct.html#gac3ca8e6e41d70a228d72422c844dc99c">cv::cuda::createGpuMatFromCudaMemory</a> (int rows, int cols, int type, size_t cudaMemoryAddress, size_t step=<a class="el" href="../../d3/d63/classcv_1_1Mat.html#a14d2089215c11acd5e8df4c6afb7002aa1c147538fd896f4f9abce9eaea9727e3">Mat::AUTO_STEP</a>)</td></tr>
<tr class="memdesc:gac3ca8e6e41d70a228d72422c844dc99c"><td class="mdescLeft"> </td><td class="mdescRight">Bindings overload to create a <a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html" title="Base storage class for GPU memory with reference counting. ">GpuMat</a> from existing GPU memory.  <a href="../../d9/d41/group__cudacore__struct.html#gac3ca8e6e41d70a228d72422c844dc99c">More...</a><br/></td></tr>
<tr class="separator:gac3ca8e6e41d70a228d72422c844dc99c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga1d874ef8ad8e4e4b32b937db00b96f80"><td align="right" class="memItemLeft" valign="top"><a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html">GpuMat</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d41/group__cudacore__struct.html#ga1d874ef8ad8e4e4b32b937db00b96f80">cv::cuda::createGpuMatFromCudaMemory</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga346f563897249351a34549137c8532a0">Size</a> size, int type, size_t cudaMemoryAddress, size_t step=<a class="el" href="../../d3/d63/classcv_1_1Mat.html#a14d2089215c11acd5e8df4c6afb7002aa1c147538fd896f4f9abce9eaea9727e3">Mat::AUTO_STEP</a>)</td></tr>
<tr class="separator:ga1d874ef8ad8e4e4b32b937db00b96f80"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga4551c222cdf97ebdb4d7440fecfc737a"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d41/group__cudacore__struct.html#ga4551c222cdf97ebdb4d7440fecfc737a">cv::cuda::ensureSizeIsEnough</a> (int rows, int cols, int type, <a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> arr)</td></tr>
<tr class="memdesc:ga4551c222cdf97ebdb4d7440fecfc737a"><td class="mdescLeft"> </td><td class="mdescRight">Ensures that the size of a matrix is big enough and the matrix has a proper type.  <a href="../../d9/d41/group__cudacore__struct.html#ga4551c222cdf97ebdb4d7440fecfc737a">More...</a><br/></td></tr>
<tr class="separator:ga4551c222cdf97ebdb4d7440fecfc737a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga6d25da8194cc95035994ae98e9eebc02"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d41/group__cudacore__struct.html#ga6d25da8194cc95035994ae98e9eebc02">cv::cuda::registerPageLocked</a> (<a class="el" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> &amp;m)</td></tr>
<tr class="memdesc:ga6d25da8194cc95035994ae98e9eebc02"><td class="mdescLeft"> </td><td class="mdescRight">Page-locks the memory of matrix and maps it for the device(s).  <a href="../../d9/d41/group__cudacore__struct.html#ga6d25da8194cc95035994ae98e9eebc02">More...</a><br/></td></tr>
<tr class="separator:ga6d25da8194cc95035994ae98e9eebc02"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga93da1d4c64558590950409266b1e2a92"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d41/group__cudacore__struct.html#ga93da1d4c64558590950409266b1e2a92">cv::cuda::setBufferPoolConfig</a> (int deviceId, size_t stackSize, int stackCount)</td></tr>
<tr class="separator:ga93da1d4c64558590950409266b1e2a92"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga7dbf253e43493eb870c9759cc35bbffb"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d41/group__cudacore__struct.html#ga7dbf253e43493eb870c9759cc35bbffb">cv::cuda::setBufferPoolUsage</a> (bool on)</td></tr>
<tr class="memdesc:ga7dbf253e43493eb870c9759cc35bbffb"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html" title="BufferPool for use with CUDA streams. ">BufferPool</a> management (must be called before <a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html" title="This class encapsulates a queue of asynchronous calls. ">Stream</a> creation)  <a href="../../d9/d41/group__cudacore__struct.html#ga7dbf253e43493eb870c9759cc35bbffb">More...</a><br/></td></tr>
<tr class="separator:ga7dbf253e43493eb870c9759cc35bbffb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga68dd974fb5e19f6306122a4b49c6a428"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d41/group__cudacore__struct.html#ga68dd974fb5e19f6306122a4b49c6a428">cv::cuda::unregisterPageLocked</a> (<a class="el" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> &amp;m)</td></tr>
<tr class="memdesc:ga68dd974fb5e19f6306122a4b49c6a428"><td class="mdescLeft"> </td><td class="mdescRight">Unmaps the memory of matrix and makes it pageable again.  <a href="../../d9/d41/group__cudacore__struct.html#ga68dd974fb5e19f6306122a4b49c6a428">More...</a><br/></td></tr>
<tr class="separator:ga68dd974fb5e19f6306122a4b49c6a428"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf7bc2ae636c98eb4cb073287b897a091"><td align="right" class="memItemLeft" valign="top"><a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html">Stream</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d41/group__cudacore__struct.html#gaf7bc2ae636c98eb4cb073287b897a091">cv::cuda::wrapStream</a> (size_t cudaStreamMemoryAddress)</td></tr>
<tr class="memdesc:gaf7bc2ae636c98eb4cb073287b897a091"><td class="mdescLeft"> </td><td class="mdescRight">Bindings overload to create a <a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html" title="This class encapsulates a queue of asynchronous calls. ">Stream</a> object from the address stored in an existing CUDA Runtime API stream pointer (cudaStream_t).  <a href="../../d9/d41/group__cudacore__struct.html#gaf7bc2ae636c98eb4cb073287b897a091">More...</a><br/></td></tr>
<tr class="separator:gaf7bc2ae636c98eb4cb073287b897a091"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3a55474eb59c884697edf397fe0f871c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a55474eb59c884697edf397fe0f871c">◆ </a></span>createContinuous()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::cuda::createContinuous </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> </td>
          <td class="paramname"><em>arr</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.cuda.createContinuous(</td><td class="paramname">rows, cols, type[, arr]</td><td>) -&gt; </td><td>arr</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../d8/dd1/modules_2core_2include_2opencv2_2core_2cuda_8hpp.html">opencv2/core/cuda.hpp</a>&gt;</code></p>
<p>Creates a continuous matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Row count. </td></tr>
    <tr><td class="paramname">cols</td><td>Column count. </td></tr>
    <tr><td class="paramname">type</td><td>Type of the matrix. </td></tr>
    <tr><td class="paramname">arr</td><td>Destination matrix. This parameter changes only if it has a proper type and area ( \(\texttt{rows} \times \texttt{cols}\) ).</td></tr>
  </table>
  </dd>
</dl>
<p>Matrix is called continuous if its elements are stored continuously, that is, without gaps at the end of each row. </p>
</div>
</div>
<a id="gac3ca8e6e41d70a228d72422c844dc99c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3ca8e6e41d70a228d72422c844dc99c">◆ </a></span>createGpuMatFromCudaMemory() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html">GpuMat</a> cv::cuda::createGpuMatFromCudaMemory </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t </td>
          <td class="paramname"><em>cudaMemoryAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t </td>
          <td class="paramname"><em>step</em> = <code><a class="el" href="../../d3/d63/classcv_1_1Mat.html#a14d2089215c11acd5e8df4c6afb7002aa1c147538fd896f4f9abce9eaea9727e3">Mat::AUTO_STEP</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.cuda.createGpuMatFromCudaMemory(</td><td class="paramname">rows, cols, type, cudaMemoryAddress[, step]</td><td>) -&gt; </td><td>retval</td></tr><tr><td style="width: 20px;"></td><td>cv.cuda.createGpuMatFromCudaMemory(</td><td class="paramname">size, type, cudaMemoryAddress[, step]</td><td>) -&gt; </td><td>retval</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../d8/dd1/modules_2core_2include_2opencv2_2core_2cuda_8hpp.html">opencv2/core/cuda.hpp</a>&gt;</code></p>
<p>Bindings overload to create a <a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html" title="Base storage class for GPU memory with reference counting. ">GpuMat</a> from existing GPU memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Row count. </td></tr>
    <tr><td class="paramname">cols</td><td>Column count. </td></tr>
    <tr><td class="paramname">type</td><td>Type of the matrix. </td></tr>
    <tr><td class="paramname">cudaMemoryAddress</td><td>Address of the allocated GPU memory on the device. This does not allocate matrix data. Instead, it just initializes the matrix header that points to the specified <em>cudaMemoryAddress</em>, which means that no data is copied. This operation is very efficient and can be used to process external data using OpenCV functions. The external data is not automatically deallocated, so you should take care of it. </td></tr>
    <tr><td class="paramname">step</td><td>Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any. If the parameter is missing (set to <a class="el" href="../../d3/d63/classcv_1_1Mat.html#a14d2089215c11acd5e8df4c6afb7002aa1c147538fd896f4f9abce9eaea9727e3">Mat::AUTO_STEP</a> ), no padding is assumed and the actual step is calculated as cols*elemSize(). See <a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html#a7e73b4fa94d32e0585564217ebe3fc6c" title="returns element size in bytes ">GpuMat::elemSize</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Overload for generation of bindings only, not exported or intended for use internally from C++. </dd></dl>
</div>
</div>
<a id="ga1d874ef8ad8e4e4b32b937db00b96f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d874ef8ad8e4e4b32b937db00b96f80">◆ </a></span>createGpuMatFromCudaMemory() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html">GpuMat</a> cv::cuda::createGpuMatFromCudaMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga346f563897249351a34549137c8532a0">Size</a> </td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t </td>
          <td class="paramname"><em>cudaMemoryAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t </td>
          <td class="paramname"><em>step</em> = <code><a class="el" href="../../d3/d63/classcv_1_1Mat.html#a14d2089215c11acd5e8df4c6afb7002aa1c147538fd896f4f9abce9eaea9727e3">Mat::AUTO_STEP</a></code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.cuda.createGpuMatFromCudaMemory(</td><td class="paramname">rows, cols, type, cudaMemoryAddress[, step]</td><td>) -&gt; </td><td>retval</td></tr><tr><td style="width: 20px;"></td><td>cv.cuda.createGpuMatFromCudaMemory(</td><td class="paramname">size, type, cudaMemoryAddress[, step]</td><td>) -&gt; </td><td>retval</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../d8/dd1/modules_2core_2include_2opencv2_2core_2cuda_8hpp.html">opencv2/core/cuda.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>2D array size: Size(cols, rows). In the <a class="el" href="../../dc/d84/group__core__basic.html#ga346f563897249351a34549137c8532a0">Size()</a> constructor, the number of rows and the number of columns go in the reverse order. </td></tr>
    <tr><td class="paramname">type</td><td>Type of the matrix. </td></tr>
    <tr><td class="paramname">cudaMemoryAddress</td><td>Address of the allocated GPU memory on the device. This does not allocate matrix data. Instead, it just initializes the matrix header that points to the specified <em>cudaMemoryAddress</em>, which means that no data is copied. This operation is very efficient and can be used to process external data using OpenCV functions. The external data is not automatically deallocated, so you should take care of it. </td></tr>
    <tr><td class="paramname">step</td><td>Number of bytes each matrix row occupies. The value should include the padding bytes at the end of each row, if any. If the parameter is missing (set to <a class="el" href="../../d3/d63/classcv_1_1Mat.html#a14d2089215c11acd5e8df4c6afb7002aa1c147538fd896f4f9abce9eaea9727e3">Mat::AUTO_STEP</a> ), no padding is assumed and the actual step is calculated as cols*elemSize(). See <a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html#a7e73b4fa94d32e0585564217ebe3fc6c" title="returns element size in bytes ">GpuMat::elemSize</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Overload for generation of bindings only, not exported or intended for use internally from C++. </dd></dl>
</div>
</div>
<a id="ga4551c222cdf97ebdb4d7440fecfc737a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4551c222cdf97ebdb4d7440fecfc737a">◆ </a></span>ensureSizeIsEnough()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::cuda::ensureSizeIsEnough </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> </td>
          <td class="paramname"><em>arr</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.cuda.ensureSizeIsEnough(</td><td class="paramname">rows, cols, type[, arr]</td><td>) -&gt; </td><td>arr</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../d8/dd1/modules_2core_2include_2opencv2_2core_2cuda_8hpp.html">opencv2/core/cuda.hpp</a>&gt;</code></p>
<p>Ensures that the size of a matrix is big enough and the matrix has a proper type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Minimum desired number of rows. </td></tr>
    <tr><td class="paramname">cols</td><td>Minimum desired number of columns. </td></tr>
    <tr><td class="paramname">type</td><td>Desired matrix type. </td></tr>
    <tr><td class="paramname">arr</td><td>Destination matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>The function does not reallocate memory if the matrix has proper attributes already. </p>
</div>
</div>
<a id="ga6d25da8194cc95035994ae98e9eebc02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d25da8194cc95035994ae98e9eebc02">◆ </a></span>registerPageLocked()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::cuda::registerPageLocked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> &amp; </td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.cuda.registerPageLocked(</td><td class="paramname">m</td><td>) -&gt; </td><td>None</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../d8/dd1/modules_2core_2include_2opencv2_2core_2cuda_8hpp.html">opencv2/core/cuda.hpp</a>&gt;</code></p>
<p>Page-locks the memory of matrix and maps it for the device(s). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Input matrix. </td></tr>
  </table>
  </dd>
</dl>
</div>
</div>
<a id="ga93da1d4c64558590950409266b1e2a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93da1d4c64558590950409266b1e2a92">◆ </a></span>setBufferPoolConfig()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::cuda::setBufferPoolConfig </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>deviceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t </td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>stackCount</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.cuda.setBufferPoolConfig(</td><td class="paramname">deviceId, stackSize, stackCount</td><td>) -&gt; </td><td>None</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../d8/dd1/modules_2core_2include_2opencv2_2core_2cuda_8hpp.html">opencv2/core/cuda.hpp</a>&gt;</code></p>
</div>
</div>
<a id="ga7dbf253e43493eb870c9759cc35bbffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dbf253e43493eb870c9759cc35bbffb">◆ </a></span>setBufferPoolUsage()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::cuda::setBufferPoolUsage </td>
          <td>(</td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>on</em></td><td>)</td>
          <td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.cuda.setBufferPoolUsage(</td><td class="paramname">on</td><td>) -&gt; </td><td>None</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../d8/dd1/modules_2core_2include_2opencv2_2core_2cuda_8hpp.html">opencv2/core/cuda.hpp</a>&gt;</code></p>
<p><a class="el" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html" title="BufferPool for use with CUDA streams. ">BufferPool</a> management (must be called before <a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html" title="This class encapsulates a queue of asynchronous calls. ">Stream</a> creation) </p>
</div>
</div>
<a id="ga68dd974fb5e19f6306122a4b49c6a428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68dd974fb5e19f6306122a4b49c6a428">◆ </a></span>unregisterPageLocked()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::cuda::unregisterPageLocked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> &amp; </td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.cuda.unregisterPageLocked(</td><td class="paramname">m</td><td>) -&gt; </td><td>None</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../d8/dd1/modules_2core_2include_2opencv2_2core_2cuda_8hpp.html">opencv2/core/cuda.hpp</a>&gt;</code></p>
<p>Unmaps the memory of matrix and makes it pageable again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Input matrix. </td></tr>
  </table>
  </dd>
</dl>
</div>
</div>
<a id="gaf7bc2ae636c98eb4cb073287b897a091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7bc2ae636c98eb4cb073287b897a091">◆ </a></span>wrapStream()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html">Stream</a> cv::cuda::wrapStream </td>
          <td>(</td>
          <td class="paramtype">size_t </td>
          <td class="paramname"><em>cudaStreamMemoryAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.cuda.wrapStream(</td><td class="paramname">cudaStreamMemoryAddress</td><td>) -&gt; </td><td>retval</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../d8/dd1/modules_2core_2include_2opencv2_2core_2cuda_8hpp.html">opencv2/core/cuda.hpp</a>&gt;</code></p>
<p>Bindings overload to create a <a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html" title="This class encapsulates a queue of asynchronous calls. ">Stream</a> object from the address stored in an existing CUDA Runtime API stream pointer (cudaStream_t). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cudaStreamMemoryAddress</td><td>Memory address stored in a CUDA Runtime API stream pointer (cudaStream_t). The created <a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html" title="This class encapsulates a queue of asynchronous calls. ">Stream</a> object does not perform any allocation or deallocation and simply wraps existing raw CUDA Runtime API stream pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Overload for generation of bindings only, not exported or intended for use internally from C++. </dd></dl>
</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 27 2023 21:56:15 for OpenCV by  <a href="http://www.doxygen.org/index.html">
<img alt="doxygen" class="footer" src="../../doxygen.png"/>
</a> 1.8.13
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
