<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>OpenCV: Use OpenCL in Android camera preview based CV application</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../tutorial-utils.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          cameramatrix: ["#1 = \\begin{bmatrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{bmatrix}", 1],
          distcoeffs: ["(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]]) \\text{ of 4, 5, 8, 12 or 14 elements}"],
          distcoeffsfisheye: ["(k_1, k_2, k_3, k_4)"],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">4.9.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d9/df8/tutorial_root.html">OpenCV Tutorials</a></li><li class="navelem"><a class="el" href="../../df/d65/tutorial_table_of_content_introduction.html">Introduction to OpenCV</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Use OpenCL in Android camera preview based CV application </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Prev Tutorial:</b> <a class="el" href="../../de/dfe/tutorial_android_dnn_intro.html">How to run deep networks on Android device</a></p>
<p><b>Next Tutorial:</b> <a class="el" href="../../d0/db2/tutorial_macos_install.html">Installation in MacOS</a></p>
<table class="doxtable">
<tr>
<th align="right"></th><th align="left"></th></tr>
<tr>
<td align="right">Original author </td><td align="left">Andrey Pavlenko, Alexander Panov </td></tr>
<tr>
<td align="right">Compatibility </td><td align="left">OpenCV &gt;= 4.9 </td></tr>
</table>
<p>This guide was designed to help you in use of <a href="https://www.khronos.org/opencl/">OpenCL &trade;</a> in Android camera preview based CV application. Tutorial was written for <a href="http://developer.android.com/tools/studio/index.html">Android Studio</a> 2022.2.1. It was tested with Ubuntu 22.04.</p>
<p>This tutorial assumes you have the following installed and configured:</p>
<ul>
<li>Android Studio (2022.2.1.+)</li>
<li>JDK 17</li>
<li>Android SDK</li>
<li>Android NDK (25.2.9519653+)</li>
<li>download OpenCV source code from <a href="../../git@github.com:opencv/opencv.git">github</a> or from <a href="https://opencv.org/releases/">releases</a> and build by <a href="https://github.com/opencv/opencv/wiki/Custom-OpenCV-Android-SDK-and-AAR-package-build">instruction on wiki</a>.</li>
</ul>
<p>It also assumes that you are familiar with Android Java and JNI programming basics. If you need help with anything of the above, you may refer to our <a class="el" href="../../d9/d3f/tutorial_android_dev_intro.html">Introduction into Android Development</a> guide.</p>
<p>This tutorial also assumes you have an Android operated device with OpenCL enabled.</p>
<p>The related source code is located within OpenCV samples at <a href="https://github.com/opencv/opencv/tree/4.x/samples/android/tutorial-4-opencl/">opencv/samples/android/tutorial-4-opencl</a> directory.</p>
<h2>How to build custom OpenCV Android SDK with OpenCL </h2>
<ol type="1">
<li><b>Assemble and configure Android OpenCL SDK.</b> The JNI part of the sample depends on standard Khornos OpenCL headers, and C++ wrapper for OpenCL and libOpenCL.so. The standard OpenCL headers may be copied from 3rdparty directory in OpenCV repository or you Linux distribution package. C++ wrapper is available in <a href="https://github.com/KhronosGroup/OpenCL-CLHPP">official Khronos reposiotry on Github</a>. Copy the header files to didicated directory in the following way: <div class="fragment"><div class="line">cd your_path/ &amp;&amp; mkdir ANDROID_OPENCL_SDK &amp;&amp; mkdir ANDROID_OPENCL_SDK/include &amp;&amp; cd ANDROID_OPENCL_SDK/include</div><div class="line">cp -r path_to_opencv/opencv/3rdparty/include/opencl/1.2/CL . &amp;&amp; cd CL</div><div class="line">wget https://github.com/KhronosGroup/OpenCL-CLHPP/raw/main/include/CL/opencl.hpp</div><div class="line">wget https://github.com/KhronosGroup/OpenCL-CLHPP/raw/main/include/CL/cl2.hpp</div></div><!-- fragment --> libOpenCL.so may be provided with BSP or just downloaded from any OpenCL-cabaple Android device with relevant arhitecture. <div class="fragment"><div class="line">cd your_path/ANDROID_OPENCL_SDK &amp;&amp; mkdir lib &amp;&amp; cd lib</div><div class="line">adb pull /system/vendor/lib64/libOpenCL.so</div></div><!-- fragment --> System verison of libOpenCL.so may have a lot of platform specific dependencies. <code>-Wl,--allow-shlib-undefined</code> flag allows to ignore 3rdparty symbols if they are not used during the build. The following CMake line allows to link the JNI part against standard OpenCL, but not include the loadLibrary into application package. System OpenCL API is used in run-time. <div class="fragment"><div class="line">target_link_libraries(${target} -lOpenCL)</div></div><!-- fragment --></li>
<li><b>Build custom OpenCV Android SDK with OpenCL.</b> OpenCL support (T-API) is disabled in OpenCV builds for Android OS by default. but it's possible to rebuild locally OpenCV for Android with OpenCL/T-API enabled: use <code>-DWITH_OPENCL=ON</code> option for CMake. You also need to specify the path to the Android OpenCL SDK: use <code>-DANDROID_OPENCL_SDK=path_to_your_Android_OpenCL_SDK</code> option for CMake. If you are building OpenCV using <code>build_sdk.py</code> please follow <a href="https://github.com/opencv/opencv/wiki/Custom-OpenCV-Android-SDK-and-AAR-package-build">instruction on wiki</a>. Set these CMake parameters in your <code>.config.py</code>, e.g. <code>ndk-18-api-level-21.config.py</code>: <div class="fragment"><div class="line">ABI(<span class="stringliteral">&quot;3&quot;</span>, <span class="stringliteral">&quot;arm64-v8a&quot;</span>, <span class="keywordtype">None</span>, 21, cmake_vars=dict(<span class="stringliteral">&#39;WITH_OPENCL&#39;</span>: <span class="stringliteral">&#39;ON&#39;</span>, <span class="stringliteral">&#39;ANDROID_OPENCL_SDK&#39;</span>: <span class="stringliteral">&#39;path_to_your_Android_OpenCL_SDK&#39;</span>))</div></div><!-- fragment --> If you are building OpenCV using cmake/ninja, use this bash script (set your NDK_VERSION and your paths instead of examples of paths): <div class="fragment"><div class="line">cd path_to_opencv &amp;&amp; mkdir build &amp;&amp; cd build</div><div class="line">export NDK_VERSION=25.2.9519653</div><div class="line">export ANDROID_SDK=/home/user/Android/Sdk/</div><div class="line">export ANDROID_OPENCL_SDK=/path_to_ANDROID_OPENCL_SDK/</div><div class="line">export ANDROID_HOME=$ANDROID_SDK</div><div class="line">export ANDROID_NDK_HOME=$ANDROID_SDK/ndk/$NDK_VERSION/</div><div class="line">cmake -GNinja -DCMAKE_TOOLCHAIN_FILE=$ANDROID_NDK_HOME/build/cmake/android.toolchain.cmake -DANDROID_STL=c++_shared -DANDROID_NATIVE_API_LEVEL=24</div><div class="line">-DANDROID_SDK=$ANDROID_SDK -DANDROID_NDK=$ANDROID_NDK_HOME -DBUILD_JAVA=ON -DANDROID_HOME=$ANDROID_SDK -DBUILD_ANDROID_EXAMPLES=ON</div><div class="line">-DINSTALL_ANDROID_EXAMPLES=ON -DANDROID_ABI=arm64-v8a -DWITH_OPENCL=ON -DANDROID_OPENCL_SDK=$ANDROID_OPENCL_SDK ..</div></div><!-- fragment --></li>
</ol>
<h2>Preface </h2>
<p>Using <a href="https://en.wikipedia.org/wiki/General-purpose_computing_on_graphics_processing_units">GPGPU</a> via OpenCL for applications performance enhancements is quite a modern trend now. Some CV algo-s (e.g. image filtering) run much faster on a GPU than on a CPU. Recently it has become possible on Android OS.</p>
<p>The most popular CV application scenario for an Android operated device is starting camera in preview mode, applying some CV algo to every frame and displaying the preview frames modified by that CV algo.</p>
<p>Let's consider how we can use OpenCL in this scenario. In particular let's try two ways: direct calls to OpenCL API and recently introduced OpenCV T-API (aka <a href="https://docs.google.com/presentation/d/1qoa29N_B-s297-fp0-b3rBirvpzJQp8dCtllLQ4DVCY/present">Transparent API</a>) - implicit OpenCL accelerations of some OpenCV algo-s.</p>
<h2>Application structure </h2>
<p>Starting Android API level 11 (Android 3.0) <a href="http://developer.android.com/reference/android/hardware/Camera.html">Camera API</a> allows use of OpenGL texture as a target for preview frames. Android API level 21 brings a new <a href="http://developer.android.com/reference/android/hardware/camera2/package-summary.html">Camera2 API</a> that provides much more control over the camera settings and usage modes, it allows several targets for preview frames and OpenGL texture in particular.</p>
<p>Having a preview frame in an OpenGL texture is a good deal for using OpenCL because there is an <a href="https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/cl_khr_gl_sharing.html">OpenGL-OpenCL Interoperability API (cl_khr_gl_sharing)</a>, allowing sharing OpenGL texture data with OpenCL functions without copying (with some restrictions of course).</p>
<p>Let's create a base for our application that just configures Android camera to send preview frames to OpenGL texture and displays these frames on display without any processing.</p>
<p>A minimal <code>Activity</code> class for that purposes looks like following:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>Tutorial4Activity <span class="keyword">extends</span> Activity {</div><div class="line"></div><div class="line">    <span class="keyword">private</span> MyGLSurfaceView mView;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> onCreate(Bundle savedInstanceState) {</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        requestWindowFeature(Window.FEATURE_NO_TITLE);</div><div class="line">        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,</div><div class="line">                WindowManager.LayoutParams.FLAG_FULLSCREEN);</div><div class="line">        getWindow().setFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON,</div><div class="line">                WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);</div><div class="line">        setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);</div><div class="line"></div><div class="line">        mView = <span class="keyword">new</span> MyGLSurfaceView(<span class="keyword">this</span>);</div><div class="line">        setContentView(mView);</div><div class="line">    }</div><div class="line"></div><div class="line">    @Override</div><div class="line">    <span class="keyword">protected</span> <span class="keywordtype">void</span> onPause() {</div><div class="line">        mView.onPause();</div><div class="line">        super.onPause();</div><div class="line">    }</div><div class="line"></div><div class="line">    @Override</div><div class="line">    <span class="keyword">protected</span> <span class="keywordtype">void</span> onResume() {</div><div class="line">        super.onResume();</div><div class="line">        mView.onResume();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>And a minimal <code>View</code> class respectively:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>MyGLSurfaceView <span class="keyword">extends</span> CameraGLSurfaceView implements CameraGLSurfaceView.CameraTextureListener {</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <a class="code" href="../../dc/d84/group__core__basic.html#ga1f6634802eeadfd7245bc75cf3e216c2">String</a> LOGTAG = <span class="stringliteral">&quot;MyGLSurfaceView&quot;</span>;</div><div class="line">    <span class="keyword">protected</span> <span class="keywordtype">int</span> procMode = NativePart.PROCESSING_MODE_NO_PROCESSING;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <a class="code" href="../../dc/d84/group__core__basic.html#ga1f6634802eeadfd7245bc75cf3e216c2">String</a>[] procModeName = <span class="keyword">new</span> <a class="code" href="../../dc/d84/group__core__basic.html#ga1f6634802eeadfd7245bc75cf3e216c2">String</a>[] {<span class="stringliteral">&quot;No Processing&quot;</span>, <span class="stringliteral">&quot;CPU&quot;</span>, <span class="stringliteral">&quot;OpenCL Direct&quot;</span>, <span class="stringliteral">&quot;OpenCL via OpenCV&quot;</span>};</div><div class="line">    <span class="keyword">protected</span> <span class="keywordtype">int</span>  frameCounter;</div><div class="line">    <span class="keyword">protected</span> <span class="keywordtype">long</span> lastNanoTime;</div><div class="line">    TextView mFpsText = null;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> MyGLSurfaceView(Context context, AttributeSet attrs) {</div><div class="line">        super(context, attrs);</div><div class="line">    }</div><div class="line"></div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keywordtype">boolean</span> onTouchEvent(MotionEvent e) {</div><div class="line">        <span class="keywordflow">if</span>(e.getAction() == MotionEvent.ACTION_DOWN)</div><div class="line">            ((Activity)getContext()).openOptionsMenu();</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> surfaceCreated(SurfaceHolder holder) {</div><div class="line">        super.surfaceCreated(holder);</div><div class="line">        <span class="comment">//NativePart.initCL();</span></div><div class="line">    }</div><div class="line"></div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> surfaceDestroyed(SurfaceHolder holder) {</div><div class="line">        <span class="comment">//NativePart.closeCL();</span></div><div class="line">        super.surfaceDestroyed(holder);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> setProcessingMode(<span class="keywordtype">int</span> newMode) {</div><div class="line">        <span class="keywordflow">if</span>(newMode&gt;=0 &amp;&amp; newMode&lt;procModeName.length)</div><div class="line">            procMode = newMode;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">            Log.e(LOGTAG, <span class="stringliteral">&quot;Ignoring invalid processing mode: &quot;</span> + newMode);</div><div class="line"></div><div class="line">        ((Activity) getContext()).runOnUiThread(<span class="keyword">new</span> Runnable() {</div><div class="line">            <span class="keyword">public</span> <span class="keywordtype">void</span> run() {</div><div class="line">                Toast.makeText(getContext(), <span class="stringliteral">&quot;Selected mode: &quot;</span> + procModeName[procMode], Toast.LENGTH_LONG).show();</div><div class="line">            }</div><div class="line">        });</div><div class="line">    }</div><div class="line"></div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> onCameraViewStarted(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height) {</div><div class="line">        ((Activity) getContext()).runOnUiThread(<span class="keyword">new</span> Runnable() {</div><div class="line">            <span class="keyword">public</span> <span class="keywordtype">void</span> run() {</div><div class="line">                Toast.makeText(getContext(), <span class="stringliteral">&quot;onCameraViewStarted&quot;</span>, Toast.LENGTH_SHORT).show();</div><div class="line">            }</div><div class="line">        });</div><div class="line">        <span class="keywordflow">if</span> (NativePart.builtWithOpenCL())</div><div class="line">            NativePart.initCL();</div><div class="line">        frameCounter = 0;</div><div class="line">        lastNanoTime = System.nanoTime();</div><div class="line">    }</div><div class="line"></div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> onCameraViewStopped() {</div><div class="line">        ((Activity) getContext()).runOnUiThread(<span class="keyword">new</span> Runnable() {</div><div class="line">            <span class="keyword">public</span> <span class="keywordtype">void</span> run() {</div><div class="line">                Toast.makeText(getContext(), <span class="stringliteral">&quot;onCameraViewStopped&quot;</span>, Toast.LENGTH_SHORT).show();</div><div class="line">            }</div><div class="line">        });</div><div class="line">    }</div><div class="line"></div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keywordtype">boolean</span> onCameraTexture(<span class="keywordtype">int</span> texIn, <span class="keywordtype">int</span> texOut, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height) {</div><div class="line">        <span class="comment">// FPS</span></div><div class="line">        frameCounter++;</div><div class="line">        <span class="keywordflow">if</span>(frameCounter &gt;= 30)</div><div class="line">        {</div><div class="line">            <span class="keyword">final</span> <span class="keywordtype">int</span> fps = (int) (frameCounter * 1e9 / (System.nanoTime() - lastNanoTime));</div><div class="line">            Log.i(LOGTAG, <span class="stringliteral">&quot;drawFrame() FPS: &quot;</span>+fps);</div><div class="line">            <span class="keywordflow">if</span>(mFpsText != null) {</div><div class="line">                Runnable fpsUpdater = <span class="keyword">new</span> Runnable() {</div><div class="line">                    <span class="keyword">public</span> <span class="keywordtype">void</span> run() {</div><div class="line">                        mFpsText.setText(<span class="stringliteral">&quot;FPS: &quot;</span> + fps);</div><div class="line">                    }</div><div class="line">                };</div><div class="line">                <span class="keyword">new</span> Handler(Looper.getMainLooper()).post(fpsUpdater);</div><div class="line">            } <span class="keywordflow">else</span> {</div><div class="line">                Log.d(LOGTAG, <span class="stringliteral">&quot;mFpsText == null&quot;</span>);</div><div class="line">                mFpsText = (TextView)((Activity) getContext()).findViewById(R.id.fps_text_view);</div><div class="line">            }</div><div class="line">            frameCounter = 0;</div><div class="line">            lastNanoTime = System.nanoTime();</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span>(procMode == NativePart.PROCESSING_MODE_NO_PROCESSING)</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        NativePart.processFrame(texIn, texOut, width, height, procMode);</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>we use two renderer classes: one for legacy <a href="http://developer.android.com/reference/android/hardware/Camera.html">Camera</a> API and another for modern <a href="http://developer.android.com/reference/android/hardware/camera2/package-summary.html">Camera2</a>.</dd></dl>
<p>A minimal <code>Renderer</code> class can be implemented in Java (OpenGL ES 2.0 <a href="http://developer.android.com/reference/android/opengl/GLES20.html">available</a> in Java), but since we are going to modify the preview texture with OpenCL let's move OpenGL stuff to JNI. Here is a simple Java wrapper for our JNI stuff:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">class </span>NativePart {</div><div class="line">    <span class="keyword">static</span></div><div class="line">    {</div><div class="line">        System.loadLibrary(<span class="stringliteral">&quot;opencv_java4&quot;</span>);</div><div class="line">        System.loadLibrary(<span class="stringliteral">&quot;JNIpart&quot;</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keywordtype">int</span> PROCESSING_MODE_NO_PROCESSING = 0;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keywordtype">int</span> PROCESSING_MODE_CPU = 1;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keywordtype">int</span> PROCESSING_MODE_OCL_DIRECT = 2;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keywordtype">int</span> PROCESSING_MODE_OCL_OCV = 3;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> native <span class="keywordtype">boolean</span> builtWithOpenCL();</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> native <span class="keywordtype">int</span> initCL();</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> native <span class="keywordtype">void</span> closeCL();</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> native <span class="keywordtype">void</span> processFrame(<span class="keywordtype">int</span> tex1, <span class="keywordtype">int</span> tex2, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h, <span class="keywordtype">int</span> mode);</div><div class="line">}</div></div><!-- fragment --><p> Since <code>Camera</code> and <code>Camera2</code> APIs differ significantly in camera setup and control, let's create a base class for the two corresponding renderers:</p>
<div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class </span>MyGLRendererBase <span class="keyword">implements</span> GLSurfaceView.Renderer, SurfaceTexture.OnFrameAvailableListener {</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <a class="code" href="../../dc/d84/group__core__basic.html#ga1f6634802eeadfd7245bc75cf3e216c2">String</a> LOGTAG = <span class="stringliteral">&quot;MyGLRendererBase&quot;</span>;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> SurfaceTexture mSTex;</div><div class="line">    <span class="keyword">protected</span> MyGLSurfaceView mView;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keywordtype">boolean</span> mGLInit = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">protected</span> <span class="keywordtype">boolean</span> mTexUpdate = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    MyGLRendererBase(MyGLSurfaceView view) {</div><div class="line">        mView = view;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keywordtype">void</span> openCamera();</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keywordtype">void</span> closeCamera();</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keywordtype">void</span> setCameraPreviewSize(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> onResume() {</div><div class="line">        Log.i(LOGTAG, <span class="stringliteral">&quot;onResume&quot;</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> onPause() {</div><div class="line">        Log.i(LOGTAG, <span class="stringliteral">&quot;onPause&quot;</span>);</div><div class="line">        mGLInit = <span class="keyword">false</span>;</div><div class="line">        mTexUpdate = <span class="keyword">false</span>;</div><div class="line">        closeCamera();</div><div class="line">        <span class="keywordflow">if</span>(mSTex != null) {</div><div class="line">            mSTex.release();</div><div class="line">            mSTex = null;</div><div class="line">            NativeGLRenderer.closeGL();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keywordtype">void</span> onFrameAvailable(SurfaceTexture surfaceTexture) {</div><div class="line">        <span class="comment">//Log.i(LOGTAG, &quot;onFrameAvailable&quot;);</span></div><div class="line">        mTexUpdate = <span class="keyword">true</span>;</div><div class="line">        mView.requestRender();</div><div class="line">    }</div><div class="line"></div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> onDrawFrame(GL10 gl) {</div><div class="line">        <span class="comment">//Log.i(LOGTAG, &quot;onDrawFrame&quot;);</span></div><div class="line">        <span class="keywordflow">if</span> (!mGLInit)</div><div class="line">            <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</div><div class="line">            <span class="keywordflow">if</span> (mTexUpdate) {</div><div class="line">                mSTex.updateTexImage();</div><div class="line">                mTexUpdate = <span class="keyword">false</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        NativeGLRenderer.drawFrame();</div><div class="line">    }</div><div class="line"></div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> onSurfaceChanged(GL10 gl, <span class="keywordtype">int</span> surfaceWidth, <span class="keywordtype">int</span> surfaceHeight) {</div><div class="line">        Log.i(LOGTAG, <span class="stringliteral">&quot;onSurfaceChanged(&quot;</span>+surfaceWidth+<span class="stringliteral">&quot;x&quot;</span>+surfaceHeight+<span class="stringliteral">&quot;)&quot;</span>);</div><div class="line">        NativeGLRenderer.changeSize(surfaceWidth, surfaceHeight);</div><div class="line">        setCameraPreviewSize(surfaceWidth, surfaceHeight);</div><div class="line">    }</div><div class="line"></div><div class="line">    @Override</div><div class="line">    <span class="keyword">public</span> <span class="keywordtype">void</span> onSurfaceCreated(GL10 gl, EGLConfig config) {</div><div class="line">        Log.i(LOGTAG, <span class="stringliteral">&quot;onSurfaceCreated&quot;</span>);</div><div class="line">        <a class="code" href="../../dc/d84/group__core__basic.html#ga1f6634802eeadfd7245bc75cf3e216c2">String</a> strGLVersion = GLES20.glGetString(GLES20.GL_VERSION);</div><div class="line">        <span class="keywordflow">if</span> (strGLVersion != null)</div><div class="line">            Log.i(LOGTAG, <span class="stringliteral">&quot;OpenGL ES version: &quot;</span> + strGLVersion);</div><div class="line"></div><div class="line">        <span class="keywordtype">int</span> hTex = NativeGLRenderer.initGL();</div><div class="line">        mSTex = <span class="keyword">new</span> SurfaceTexture(hTex);</div><div class="line">        mSTex.setOnFrameAvailableListener(<span class="keyword">this</span>);</div><div class="line">        openCamera();</div><div class="line">        mGLInit = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>As you can see, inheritors for <code>Camera</code> and <code>Camera2</code> APIs should implement the following abstract methods: </p><div class="fragment"><div class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keywordtype">void</span> openCamera();</div><div class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keywordtype">void</span> closeCamera();</div><div class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keywordtype">void</span> setCameraPreviewSize(<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height);</div></div><!-- fragment --><p>Let's leave the details of their implementation beyond of this tutorial, please refer the <a href="https://github.com/opencv/opencv/tree/4.x/samples/android/tutorial-4-opencl/">source code</a> to see them.</p>
<h2>Preview Frames modification </h2>
<p>The details OpenGL ES 2.0 initialization are also quite straightforward and noisy to be quoted here, but the important point here is that the OpeGL texture to be the target for camera preview should be of type <code>GL_TEXTURE_EXTERNAL_OES</code> (not <code>GL_TEXTURE_2D</code>), internally it keeps picture data in <em>YUV</em> format. That makes unable sharing it via CL-GL interop (<code>cl_khr_gl_sharing</code>) and accessing its pixel data via C/C++ code. To overcome this restriction we have to perform an OpenGL rendering from this texture to another regular <code>GL_TEXTURE_2D</code> one using <em>FrameBuffer Object</em> (aka FBO).</p>
<h3>C/C++ code</h3>
<p>After that we can read (<em>copy</em>) pixel data from C/C++ via <code>glReadPixels()</code> and write them back to texture after modification via <code>glTexSubImage2D()</code>.</p>
<h3>Direct OpenCL calls</h3>
<p>Also that <code>GL_TEXTURE_2D</code> texture can be shared with OpenCL without copying, but we have to create OpenCL context with special way for that:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> initCL()</div><div class="line">{</div><div class="line">    dumpCLinfo();</div><div class="line">    LOGE(<span class="stringliteral">&quot;initCL: start initCL&quot;</span>);</div><div class="line">    EGLDisplay mEglDisplay = eglGetCurrentDisplay();</div><div class="line">    <span class="keywordflow">if</span> (mEglDisplay == EGL_NO_DISPLAY)</div><div class="line">        LOGE(<span class="stringliteral">&quot;initCL: eglGetCurrentDisplay() returned &#39;EGL_NO_DISPLAY&#39;, error = %x&quot;</span>, eglGetError());</div><div class="line"></div><div class="line">    EGLContext mEglContext = eglGetCurrentContext();</div><div class="line">    <span class="keywordflow">if</span> (mEglContext == EGL_NO_CONTEXT)</div><div class="line">        LOGE(<span class="stringliteral">&quot;initCL: eglGetCurrentContext() returned &#39;EGL_NO_CONTEXT&#39;, error = %x&quot;</span>, eglGetError());</div><div class="line"></div><div class="line">    cl_context_properties props[] =</div><div class="line">    {   CL_GL_CONTEXT_KHR,   (cl_context_properties) mEglContext,</div><div class="line">        CL_EGL_DISPLAY_KHR,  (cl_context_properties) mEglDisplay,</div><div class="line">        CL_CONTEXT_PLATFORM, 0,</div><div class="line">        0 };</div><div class="line"></div><div class="line">    <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">        <a class="code" href="../../dc/d83/group__core__opencl.html#gaf8716694664cb127e7928c335b97d217">haveOpenCL</a> = <span class="keyword">false</span>;</div><div class="line">        cl::Platform p = cl::Platform::getDefault();</div><div class="line">        std::string ext = p.getInfo&lt;CL_PLATFORM_EXTENSIONS&gt;();</div><div class="line">        <span class="keywordflow">if</span>(ext.find(<span class="stringliteral">&quot;cl_khr_gl_sharing&quot;</span>) == std::string::npos)</div><div class="line">            LOGE(<span class="stringliteral">&quot;Warning: CL-GL sharing isn&#39;t supported by PLATFORM&quot;</span>);</div><div class="line">        props[5] = (cl_context_properties) p();</div><div class="line"></div><div class="line">        theContext = cl::Context(CL_DEVICE_TYPE_GPU, props);</div><div class="line">        std::vector&lt;cl::Device&gt; devs = theContext.getInfo&lt;CL_CONTEXT_DEVICES&gt;();</div><div class="line">        LOGD(<span class="stringliteral">&quot;Context returned %d devices, taking the 1st one&quot;</span>, devs.size());</div><div class="line">        ext = devs[0].getInfo&lt;CL_DEVICE_EXTENSIONS&gt;();</div><div class="line">        <span class="keywordflow">if</span>(ext.find(<span class="stringliteral">&quot;cl_khr_gl_sharing&quot;</span>) == std::string::npos)</div><div class="line">            LOGE(<span class="stringliteral">&quot;Warning: CL-GL sharing isn&#39;t supported by DEVICE&quot;</span>);</div><div class="line"></div><div class="line">        theQueue = cl::CommandQueue(theContext, devs[0]);</div><div class="line"></div><div class="line">        cl::Program::Sources src(1, std::make_pair(oclProgI2I, <span class="keyword">sizeof</span>(oclProgI2I)));</div><div class="line">        theProgI2I = cl::Program(theContext, src);</div><div class="line">        theProgI2I.build(devs);</div><div class="line"></div><div class="line">        <a class="code" href="../../dc/d83/group__core__opencl.html#gaf83af36be2097fd43e3eba5c8f3025b1">cv::ocl::attachContext</a>(p.getInfo&lt;CL_PLATFORM_NAME&gt;(), p(), theContext(), devs[0]());</div><div class="line">        <span class="keywordflow">if</span>( <a class="code" href="../../dc/d83/group__core__opencl.html#gadb3b41d4552e9db7887855e3a1b2af37">cv::ocl::useOpenCL</a>() )</div><div class="line">            LOGD(<span class="stringliteral">&quot;OpenCV+OpenCL works OK!&quot;</span>);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">            LOGE(<span class="stringliteral">&quot;Can&#39;t init OpenCV with OpenCL TAPI&quot;</span>);</div><div class="line">        <a class="code" href="../../dc/d83/group__core__opencl.html#gaf8716694664cb127e7928c335b97d217">haveOpenCL</a> = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span>(<span class="keyword">const</span> cl::Error&amp; e)</div><div class="line">    {</div><div class="line">        LOGE(<span class="stringliteral">&quot;cl::Error: %s (%d)&quot;</span>, e.what(), e.err());</div><div class="line">        <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span>(<span class="keyword">const</span> std::exception&amp; e)</div><div class="line">    {</div><div class="line">        LOGE(<span class="stringliteral">&quot;std::exception: %s&quot;</span>, e.what());</div><div class="line">        <span class="keywordflow">return</span> 2;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">catch</span>(...)</div><div class="line">    {</div><div class="line">        LOGE( <span class="stringliteral">&quot;OpenCL info: unknown error while initializing OpenCL stuff&quot;</span> );</div><div class="line">        <span class="keywordflow">return</span> 3;</div><div class="line">    }</div><div class="line">    LOGD(<span class="stringliteral">&quot;initCL completed&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="../../dc/d83/group__core__opencl.html#gaf8716694664cb127e7928c335b97d217">haveOpenCL</a>)</div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">return</span> 4;</div><div class="line">}</div></div><!-- fragment --><p> Then the texture can be wrapped by a <code>cl::ImageGL</code> object and processed via OpenCL calls:</p>
<div class="fragment"><div class="line">    cl::ImageGL imgIn (theContext, CL_MEM_READ_ONLY,  GL_TEXTURE_2D, 0, texIn);</div><div class="line">    cl::ImageGL imgOut(theContext, CL_MEM_WRITE_ONLY, GL_TEXTURE_2D, 0, texOut);</div><div class="line">    std::vector &lt; cl::Memory &gt; images;</div><div class="line">    images.push_back(imgIn);</div><div class="line">    images.push_back(imgOut);</div><div class="line"></div><div class="line">    <a class="code" href="../../d2/d75/namespacecv.html#a206f22cea0deff11cbac113b87afff00">int64_t</a> t = getTimeMs();</div><div class="line">    theQueue.enqueueAcquireGLObjects(&amp;images);</div><div class="line">    theQueue.finish();</div><div class="line">    LOGD(<span class="stringliteral">&quot;enqueueAcquireGLObjects() costs %d ms&quot;</span>, getTimeInterval(t));</div><div class="line"></div><div class="line">    t = getTimeMs();</div><div class="line">    cl::Kernel <a class="code" href="../../d4/d86/group__imgproc__filter.html#gad78703e4c8fe703d479c1860d76429e6">Laplacian</a>(theProgI2I, <span class="stringliteral">&quot;Laplacian&quot;</span>); <span class="comment">//TODO: may be done once</span></div><div class="line">    <a class="code" href="../../d4/d86/group__imgproc__filter.html#gad78703e4c8fe703d479c1860d76429e6">Laplacian</a>.setArg(0, imgIn);</div><div class="line">    <a class="code" href="../../d4/d86/group__imgproc__filter.html#gad78703e4c8fe703d479c1860d76429e6">Laplacian</a>.setArg(1, imgOut);</div><div class="line">    theQueue.finish();</div><div class="line">    LOGD(<span class="stringliteral">&quot;Kernel() costs %d ms&quot;</span>, getTimeInterval(t));</div><div class="line"></div><div class="line">    t = getTimeMs();</div><div class="line">    theQueue.enqueueNDRangeKernel(<a class="code" href="../../d4/d86/group__imgproc__filter.html#gad78703e4c8fe703d479c1860d76429e6">Laplacian</a>, cl::NullRange, cl::NDRange(w, h), cl::NullRange);</div><div class="line">    theQueue.finish();</div><div class="line">    LOGD(<span class="stringliteral">&quot;enqueueNDRangeKernel() costs %d ms&quot;</span>, getTimeInterval(t));</div><div class="line"></div><div class="line">    t = getTimeMs();</div><div class="line">    theQueue.enqueueReleaseGLObjects(&amp;images);</div><div class="line">    theQueue.finish();</div><div class="line">    LOGD(<span class="stringliteral">&quot;enqueueReleaseGLObjects() costs %d ms&quot;</span>, getTimeInterval(t));</div></div><!-- fragment --> <h3>OpenCV T-API</h3>
<p>But instead of writing OpenCL code by yourselves you may want to use <b>OpenCV T-API</b> that calls OpenCL implicitly. All that you need is to pass the created OpenCL context to OpenCV (via <code><a class="el" href="../../dc/d83/group__core__opencl.html#gaf83af36be2097fd43e3eba5c8f3025b1" title="Attaches OpenCL context to OpenCV. ">cv::ocl::attachContext()</a></code>) and somehow wrap OpenGL texture with <code><a class="el" href="../../d7/d45/classcv_1_1UMat.html">cv::UMat</a></code>. Unfortunately <code>UMat</code> keeps OpenCL <em>buffer</em> internally, that can't be wrapped over either OpenGL <em>texture</em> or OpenCL <em>image</em> - so we have to copy image data here:</p>
<div class="fragment"><div class="line">    <a class="code" href="../../d2/d75/namespacecv.html#a206f22cea0deff11cbac113b87afff00">int64_t</a> t = getTimeMs();</div><div class="line">    cl::ImageGL imgIn (theContext, CL_MEM_READ_ONLY,  GL_TEXTURE_2D, 0, texIn);</div><div class="line">    std::vector &lt; cl::Memory &gt; images(1, imgIn);</div><div class="line">    theQueue.enqueueAcquireGLObjects(&amp;images);</div><div class="line">    theQueue.finish();</div><div class="line">    <a class="code" href="../../d7/d45/classcv_1_1UMat.html">cv::UMat</a> uIn, uOut, uTmp;</div><div class="line">    <a class="code" href="../../dc/d83/group__core__opencl.html#gada97cc08c31e416b957e23b480334b6c">cv::ocl::convertFromImage</a>(imgIn(), uIn);</div><div class="line">    LOGD(<span class="stringliteral">&quot;loading texture data to OpenCV UMat costs %d ms&quot;</span>, getTimeInterval(t));</div><div class="line">    theQueue.enqueueReleaseGLObjects(&amp;images);</div><div class="line"></div><div class="line">    t = getTimeMs();</div><div class="line">    <span class="comment">//cv::blur(uIn, uOut, cv::Size(5, 5));</span></div><div class="line">    <a class="code" href="../../d4/d86/group__imgproc__filter.html#gad78703e4c8fe703d479c1860d76429e6">cv::Laplacian</a>(uIn, uTmp, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga32b18d904ee2b1731a9416a8eef67d06">CV_8U</a>);</div><div class="line">    <a class="code" href="../../d2/d75/namespacecv.html">cv</a>:<a class="code" href="../../d2/de8/group__core__array.html#ga979d898a58d7f61c53003e162e7ad89f">multiply</a>(uTmp, 10, uOut);</div><div class="line">    <a class="code" href="../../dc/d83/group__core__opencl.html#gabfca32247f267c662b3bff6587d14b40">cv::ocl::finish</a>();</div><div class="line">    LOGD(<span class="stringliteral">&quot;OpenCV processing costs %d ms&quot;</span>, getTimeInterval(t));</div><div class="line"></div><div class="line">    t = getTimeMs();</div><div class="line">    cl::ImageGL imgOut(theContext, CL_MEM_WRITE_ONLY, GL_TEXTURE_2D, 0, texOut);</div><div class="line">    images.clear();</div><div class="line">    images.push_back(imgOut);</div><div class="line">    theQueue.enqueueAcquireGLObjects(&amp;images);</div><div class="line">    cl_mem clBuffer = (cl_mem)uOut.<a class="code" href="../../d7/d45/classcv_1_1UMat.html#afdbe2f205e6bb5475b252b598376188e">handle</a>(<a class="code" href="../../dc/d84/group__core__basic.html#gga6226c29c7b0e7bda7aff72e96ba8e1dfa39d5f615d02cac084ab1dd0cb4f7c221">cv::ACCESS_READ</a>);</div><div class="line">    cl_command_queue q = (cl_command_queue)<a class="code" href="../../dd/dc0/classcv_1_1ocl_1_1Queue.html#a4f7a22c9c0f2b2c6ee6b47cc19519fef">cv::ocl::Queue::getDefault</a>().<a class="code" href="../../dd/dc0/classcv_1_1ocl_1_1Queue.html#a8d201148fb55a19e748b20b2f50a0610">ptr</a>();</div><div class="line">    <span class="keywordtype">size_t</span> offset = 0;</div><div class="line">    <span class="keywordtype">size_t</span> origin[3] = { 0, 0, 0 };</div><div class="line">    <span class="keywordtype">size_t</span> region[3] = { (size_t)w, (<span class="keywordtype">size_t</span>)h, 1 };</div><div class="line">    <a class="code" href="../../db/de0/group__core__utils.html#gaf62bcd90f70e275191ab95136d85906b">CV_Assert</a>(clEnqueueCopyBufferToImage (q, clBuffer, imgOut(), offset, origin, region, 0, NULL, NULL) == CL_SUCCESS);</div><div class="line">    theQueue.enqueueReleaseGLObjects(&amp;images);</div><div class="line">    <a class="code" href="../../dc/d83/group__core__opencl.html#gabfca32247f267c662b3bff6587d14b40">cv::ocl::finish</a>();</div><div class="line">    LOGD(<span class="stringliteral">&quot;uploading results to texture costs %d ms&quot;</span>, getTimeInterval(t));</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>We have to make one more image data copy when placing back the modified image to the original OpenGL texture via OpenCL image wrapper.</dd></dl>
<h2>Performance notes </h2>
<p>To compare the performance we measured FPS of the same preview frames modification (<em>Laplacian</em>) done by C/C++ code (call to <code><a class="el" href="../../d4/d86/group__imgproc__filter.html#gad78703e4c8fe703d479c1860d76429e6" title="Calculates the Laplacian of an image. ">cv::Laplacian</a></code> with <code><a class="el" href="../../d3/d63/classcv_1_1Mat.html" title="n-dimensional dense array class ">cv::Mat</a></code>), by direct OpenCL calls (using OpenCL <em>images</em> for input and output), and by OpenCV <em>T-API</em> (call to <code><a class="el" href="../../d4/d86/group__imgproc__filter.html#gad78703e4c8fe703d479c1860d76429e6" title="Calculates the Laplacian of an image. ">cv::Laplacian</a></code> with <code><a class="el" href="../../d7/d45/classcv_1_1UMat.html">cv::UMat</a></code>) on <em>Sony Xperia Z3</em> with 720p camera resolution:</p><ul>
<li><b>C/C++ version</b> shows <b>3-4 fps</b></li>
<li><b>direct OpenCL calls</b> shows <b>25-27 fps</b></li>
<li><b>OpenCV T-API</b> shows <b>11-13 fps</b> (due to extra copying from <code>cl_image</code> to <code>cl_buffer</code> and back) </li>
</ul>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 27 2023 21:56:13 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
